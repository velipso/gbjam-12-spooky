<!doctype html>
<html lang="en">
<head>
  <title>GBJam 12 - Spooky</title>
  <style>

html, body {
  background-color: #000;
  font-family: sans-serif;
  font-size: 18px;
  line-height: 24px;
  color: #ffffff;
  text-align: center;
}

a {
  color: #7a7a7a;
  text-decoration: none;
}

a:hover, a:active {
  color: #ffffff;
  text-decoration: underline;
}

#cnv {
  display: block;
  width: 640px;
  height: 576px;
  margin: 16px auto;
  image-rendering: pixelated;
  border: 1px solid #3a3a3a;
  border-radius: 8px;
}

#debug {
  display: block; /* TODO: hide */
  text-align: center;
  margin: 10px;
}

#debug button {
  font-size: 20px;
  min-width: 25px;
}

#controls {
  text-align: left;
  width: 300px;
  margin: 16px auto;
  padding: 16px;
  background-color: #3a3a3a;
  border-radius: 8px;
}

#controls > p {
  margin: 0 0 8px 0;
  padding: 0;
}

#controls > p > strong {
  display: inline-block;
  width: 120px;
}

#fps {
  color: #3a3a3a;
}
  </style>
  <script src="./howler.core.min.js"></script>
</head>
<body>
  <canvas id="cnv" width="160" height="144"></canvas>
  <div id="controls">
    <div id="debug">
      <button onClick="javascript:debug=!debug">Debug</button>
      <button onClick="javascript:playerEntity.keys = 100;">Keys</button>
      <button onClick="javascript:loadLevel(levelNames.indexOf('1-1'));">1</button>
      <button onClick="javascript:loadLevel(levelNames.indexOf('2-1'));">2</button>
      <button onClick="javascript:loadLevel(levelNames.indexOf('3-1'));">3</button>
      <button onClick="javascript:loadLevel(levelNames.indexOf('4-1'));">4</button><br />
      <input id="c0" type="color" value="#000000" onInput="javascript: refreshPalette();" />
      <input id="c1" type="color" value="#3a3a3a" onInput="javascript: refreshPalette();" />
      <input id="c2" type="color" value="#7a7a7a" onInput="javascript: refreshPalette();" />
      <input id="c3" type="color" value="#c0c0c0" onInput="javascript: refreshPalette();" /><br />
      <span id="palette" style="font-family: monospace; font-size: 12px;"></span>
    </div>
    <p style="font-weight: bold; text-decoration: underline; text-align: center;">Controls</p>
    <p>
      <strong>Left / Right</strong> Move</br >
      <strong>Up</strong> Enter Door</br >
      <strong>Z</strong> Run / Attack<br />
      <strong>X</strong> Jump<br />
      <strong>Enter</strong> Start / OK
    </p>
    <p style="margin-top: 16px; border-top: 1px solid #7a7a7a; padding-top: 16px;">
      <strong>Music</strong><select id="musicVol">
        <option value="0">Off</option>
        <option value="0.25">25%</option>
        <option value="0.5" selected>50%</option>
        <option value="0.75">75%</option>
        <option value="1.00">100%</option>
      </select>
      <strong>Sfx</strong><select id="sfxVol">
        <option value="0">Off</option>
        <option value="0.25">25%</option>
        <option value="0.5" selected>50%</option>
        <option value="0.75">75%</option>
        <option value="1.00">100%</option>
      </select><br />
      <strong>Gamepad</strong><select id="enableGamepad">
        <option value="true">Enable</option>
        <option value="false">Disable</option>
      </select>
    </p>
  </div>
  <p id="fps">FPS: ?</p>
  <p>
    &copy; Copyright 2024 <a href="https://pulp.biz">Pocket Pulp LLC</a>, 0BSD
  </p>
  <script>
const fps = document.getElementById('fps');
const cnv = document.getElementById('cnv');
const ctx = cnv.getContext('2d');
const input = {
  up: false,
  down: false,
  left: false,
  right: false,
  start: false,
  hitStart: false,
  jump: false,
  hitJump: false,
  second: false,
  hitSecond: false,
};
const keyboard = {
  up: false,
  down: false,
  left: false,
  right: false,
  start: false,
  hitStart: false,
  jump: false,
  hitJump: false,
  second: false,
  hitSecond: false,
};
let enableGamepad = true;
let debug = false;
const gamepad = {
  jump: false,
  hitJump: false,
  second: false,
  hitSecond: false,
  start: false,
  hitStart: false,
  up: false,
  right: false,
  down: false,
  left: false,
};
const gpButton = {
  jump: 0,
  second: 2,
  start: 9,
  up: 12,
  right: 15,
  down: 13,
  left: 14
};
const totalTime = {
  startNow: 0,
  startFrames: 0,
  endNow: 0,
  endFrames: 0
};
const levels = [false];
const levelNames = [''];
let vclampCamera = false;
let invincible = false;
let targetFPS = 60;
let beatGame = false;
let currentLevel = 0;
let cameraX = 0;
let cameraY = 0;
let L, LO;
let ignoreSpawnerIds = [];
let gameMode = 'title';
let theEnd = false;
const maxHearts = 3;
const lerp = (a, b, t) => a + (b - a) * t;

const entityOverlap = (a, b) => {
  const ax1 = a.x;
  const ay1 = a.y;
  const ax2 = a.x + a.width - 1;
  const ay2 = a.y + a.height - 1;
  const bx1 = b.x;
  const bx2 = b.x + b.width - 1;
  const by1 = b.y;
  const by2 = b.y + b.height - 1;
  return !(bx1 > ax2 || bx2 < ax1 || by1 > ay2 || by2 < ay1);
};

class ImagesContainer {
  tiles = null;
  boss = null;
  sprites = null;
  title = null;
  bg = null;
  src = {};
  clearColor = '#000';

  setPalette(c0, c1, c2, c3) {
    const rgba = [
      [0, 0, 0, 0],
      [(c0 >> 16) & 0xff, (c0 >> 8) & 0xff, c0 & 0xff, 0xff],
      [(c1 >> 16) & 0xff, (c1 >> 8) & 0xff, c1 & 0xff, 0xff],
      [(c2 >> 16) & 0xff, (c2 >> 8) & 0xff, c2 & 0xff, 0xff],
      [(c3 >> 16) & 0xff, (c3 >> 8) & 0xff, c3 & 0xff, 0xff],
    ];
    const hex = (v) => '#' + `000000${v.toString(16)}`.substr(-6);
    this.clearColor = hex(c0);
    document.getElementById('c0').value = hex(c0);
    document.getElementById('c1').value = hex(c1);
    document.getElementById('c2').value = hex(c2);
    document.getElementById('c3').value = hex(c3);
    for (const [k, v] of Object.entries(this.src)) {
      const cnv = document.createElement('canvas');
      cnv.width = v.width;
      cnv.height = v.height;
      const ctx = cnv.getContext('2d');
      const id = ctx.getImageData(0, 0, cnv.width, cnv.height);
      for (let y = 0; y < v.height; y++) {
        for (let x = 0; x < v.width; x++) {
          const j = x + y * v.width;
          const k = j * 4;
          const c = rgba[v.data[j]];
          id.data[k + 0] = c[0];
          id.data[k + 1] = c[1];
          id.data[k + 2] = c[2];
          id.data[k + 3] = c[3];
        }
      }
      ctx.putImageData(id, 0, 0);
      this[k] = cnv;
    }
  }

  load(key, src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.src = src;
      if (img.complete) {
        resolve(img);
      } else {
        img.onload = () => {
          resolve(img);
        };
      }
    }).then((img) => {
      const cnv = document.createElement('canvas');
      cnv.width = img.width;
      cnv.height = img.height;
      const ctx = cnv.getContext('2d');
      ctx.clearRect(0, 0, cnv.width, cnv.height);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0);
      const id = ctx.getImageData(0, 0, cnv.width, cnv.height);
      const data = new Uint8Array(img.width * img.height);
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          const j = x + y * img.width;
          const k = j * 4;
          let col = 0;
          if (id.data[k + 3] > 127) {
            const c = Math.round((id.data[k] + id.data[k + 1] + id.data[k + 2]) / 3);
            const cols = [
              [1, Math.abs(c - 0x00)],
              [2, Math.abs(c - 0x3a)],
              [3, Math.abs(c - 0x7a)],
              [4, Math.abs(c - 0xc0)]
            ];
            cols.sort((a, b) => a[1] - b[1]);
            col = cols[0][0];
          }
          data[j] = col;
        }
      }
      this.src[key] = { width: img.width, height: img.height, data };
    });
  }
}

const ic = new ImagesContainer();

function refreshPalette() {
  const c0 = document.getElementById('c0').value;
  const c1 = document.getElementById('c1').value;
  const c2 = document.getElementById('c2').value;
  const c3 = document.getElementById('c3').value;
  document.getElementById('palette').innerText = c0 + ' ' + c1 + ' ' + c2 + ' ' + c3;
  ic.setPalette(
    parseInt(c0.substr(1), 16),
    parseInt(c1.substr(1), 16),
    parseInt(c2.substr(1), 16),
    parseInt(c3.substr(1), 16)
  );
}

class ParticleEntity {
  skipOverlap = true;
  alive = true;
  x = 22;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0.5;
  maxSpeed = [-8, 5];
  mx = 0;
  my = 0;
  width = 4;
  height = 4;
  facing = 1;
  frame = 0;
  odx = 0;
  tileX = 0;
  tileY = 0;

  constructor(x, y, dx, dy) {
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.dy = dy;
    this.odx = dx;
    this.tileX = Math.floor(Math.random() * 4);
    this.tileY = Math.floor(Math.random() * 2);
    this.tileFlags = Math.floor(Math.random() * 4) * 2;
  }

  think() {
    this.frame++;
    if (this.frame > 100) {
      this.alive = false;
    }
  }

  fire(ev, ov) {
    if (ev === 'bonk-down') {
      this.dx = 0.9 * this.dx;
    }
    if (ov > 0 && ev === 'bonk-down') {
      this.dy = -0.8 * ov;
      if (Math.abs(this.dy) < 1.5) this.dy = 0;
    } else if (ov < 0 && ev === 'bonk-up') {
      this.dy = 0;
    } else if (
      (this.odx < 0 && ev === 'bonk-left') ||
      (this.odx > 0 && ev === 'bonk-right')
    ) {
      this.odx = -0.9 * this.odx;
      this.dx = this.odx;
    }
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;
    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#f00';
      ctx.fillRect(x, y, this.width, this.height);
    }
    drawImage(ic.sprites, 48 + this.tileX * 4, 224 + this.tileY * 4, 5, 5, x, y, this.tileFlags);
  }
}

class ItemEntity {
  skipDamage = true;
  skipPhysics = true;
  alive = true;
  kind = 'coin';
  id = -1;
  x = 22;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0.5;
  maxSpeed = [-8, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 11;
  facing = 1;
  frame = 0;
  startY = 0;
  icon = 0;

  constructor(x, y, kind, id) {
    this.x = x;
    this.y = y;
    this.startY = y;
    this.kind = kind;
    this.id = id;
    this.icon = ((x / tileSize) + (y / tileSize)) % 4;
    this.frame = this.icon * 16;
  }

  launch(dx, dy) {
    this.skipPhysics = false;
    this.dx = dx;
    this.odx = dx;
    this.dy = dy;
    this.icon = Math.floor(Math.random() * 4);
  }

  think() {
    if (!this.skipPhysics) {
      return;
    }
    this.frame++;
    this.y = Math.round(this.startY - (1 - Math.cos(this.frame * 0.1)) * 1.5);
  }

  fire(ev, ov) {
    if (ev === 'touch') {
      // collect item
      if (this.kind === 'key') {
        playerEntity.keys++;
      } else if (this.kind === 'heart') {
        playerEntity.hearts = Math.min(maxHearts, playerEntity.hearts + 1);
      } else if (this.kind === 'coin') {
        playerEntity.coins++;
        playerEntity.score += 5;
      }
      if (this.id >= 0) {
        ignoreSpawnerIds.push(this.id);
      }
      this.alive = false;
    }
    if (!this.skipPhysics) {
      if (ev === 'bonk-down') {
        this.dx = 0.95 * this.dx;
      }
      if (ov > 0 && ev === 'bonk-down') {
        this.dy = -0.95 * ov;
        if (Math.abs(this.dy) < 1.5) this.dy = 0;
      } else if (ov < 0 && ev === 'bonk-up') {
        this.dy = 0;
      } else if (
        (this.odx < 0 && ev === 'bonk-left') ||
        (this.odx > 0 && ev === 'bonk-right')
      ) {
        this.odx = -0.95 * this.odx;
        this.dx = this.odx;
      }
    }
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#f00';
      ctx.fillRect(x, y, this.width, this.height);
      ctx.fillText(this.kind, x, y);
    }

    if (this.kind === 'coin') {
      const ix = (this.icon & 1) * 16;
      const iy = (this.icon >> 1) * 16;
      drawImage(ic.sprites, ix, iy + 224, 16, 16, x - 2, y - 2, 0);
    } else if (this.kind === 'heart') {
      drawImage(ic.sprites, 32, 224, 16, 16, x - 2, y - 2, 0);
    } else {
      drawImage(ic.sprites, 64, 224, 32, 32, x - 11, y - 11, 0);
    }
  }
}

function spawnParticles(name, entity) {
  const edx = 'dx' in entity ? entity.dx : 0;
  const max = Math.max(4, Math.min(16, Math.round(entity.width * entity.height * 0.03)));
  for (let i = 0; i < max; i++) {
    const x = entity.x + Math.round(Math.random() * (entity.width - 4));
    const y = entity.y + Math.round(Math.random() * (entity.height - 4));
    const ang = Math.random() * 2 * Math.PI;
    const dx = Math.cos(ang) + edx;
    const dy = -5 * Math.abs(Math.sin(ang));
    entities.push(new ParticleEntity(x, y, dx, dy));
  }
}

class UserEntity {
  alive = true;
  player = 'witch';
  x = 22;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0.5;
  maxSpeed = [-8, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 22;
  air = 0;
  facing = 1;
  attackRect = [0, 0, 11, 16];
  attack = 0;
  keys = 0;
  doorAni = 0;
  doorTarget = 0;
  airCharge = 0;
  lastAir0 = 0;
  airAni = 0;
  brokeAni = 0;
  bounceAni = 0;
  hearts = maxHearts;
  coins = 0;
  deathAni = 0;
  spawnPos = [0, 0];
  drawBehind = false;
  lockedDoor = false;
  score = 0;

  respawn() {
    this.hearts = maxHearts;
    this.deathAni = 0;
    this.ddy = 0.5;
    this.x = this.spawnPos[0];
    this.y = this.spawnPos[1];
    this.facing = 1;
    this.iframes = 0;
  }

  setSpawn(x, y) {
    this.x = x;
    this.y = y;
    this.spawnPos = [x, y];
  }

  think() {
    if (this.deathAni > 0) {
      this.dx = 0;
      this.dy = 0;
      this.ddy = 0;
      this.deathAni--;
      if (this.deathAni <= 0) {
        if (currentLevel === 3) { // boss fight
          gameMode = 'choose';
          loadLevel(3);
        } else {
          this.respawn();
          gameMode = 'choose';
        }
      }
      return;
    }

    // swap door background graphic
    const updateDoorTiles = (dwt) => {
      const update = (lv) => {
        const xy = lv.doors.find(d => d.door === this.doorTarget);
        const k = xy.x + xy.y * lv.width;
        lv.world[k] += dwt;
        lv.world[k + lv.width] += dwt;
      };
      update(L);
      update(LO);
    };

    this.drawBehind = this.doorAni >= 11 && this.doorAni <= 30;
    if (this.doorAni > 0) {
      this.doorAni++;
      const di = this.doorAni - 2;
      if (di === 29) {
        // swap levels
        const T = L;
        L = LO;
        LO = T;
        spawnEntities();
        // load player position
        const xy = L.doors.find(d => d.door === this.doorTarget);
        this.setSpawn(
          xy.x * tileSize,
          xy.y * tileSize
        );
      } else if (di === 39) {
        this.doorAni = 0;
        updateDoorTiles(2);
      }
      return;
    }

    let a = 0; // max horizontal speed
    let f = 0; // horizontal acceleration
    switch (this.player) {
      case 'witch':
        a = input.second ? 2.5 : 1.8;
        f = this.air <= 0 ? 0.5 : 0.2;
        this.ddy = 0.5;
        break;
      case 'wolf':
        a = input.second ? 2 : 1.5;
        f = this.air <= 0 ? 0.5 : 0.2;
        this.ddy = 0.5;
        break;
      case 'vampire': {
        let alreadyDecreased = false;
        const decreaseAirCharge = () => {
          if (alreadyDecreased) {
            return true;
          }
          if (this.airCharge > 0) {
            alreadyDecreased = true;
            this.airCharge--;
            return true;
          }
          return false;
        };
        a = this.air <= 0
          ? (input.second ? 2.5 : 1.8) // walking speed
          : this.dy > 0 // is falling?
          ? (
            input.jump && decreaseAirCharge() // is using air charge?
              ? (input.second ? 1.2 : 0.6)
              : (input.second ? 2.5 : 1.8)
            )
          : ( // rising
            this.air < 170
            ? lerp(input.second ? 2.5 : 1.8, 0.1, (this.air - 100) / 70)
            : 0.1
          );
        f = this.air <= 0 ? 1 : 0.2;
        this.ddy = this.dy > 0 ? (input.jump && decreaseAirCharge() ? 0.06 : 0.25) : 0.12;
        if (this.dy > 0 && input.jump && decreaseAirCharge()) {
          this.dy = Math.min(this.dy, 1.5);
        }
        break;
      }
    }

    let water = false;
    this.lockedDoor = false;
    let push = 0;
    {
      const sx = Math.floor(this.x / tileSize);
      const ex = Math.floor((this.x + this.width - 1) / tileSize);
      const sy = Math.floor(this.y / tileSize);
      const ey = Math.floor((this.y + this.height - 1) / tileSize);
      for (let iy = sy; iy <= ey; iy++) {
        for (let ix = sx; ix <= ex; ix++) {
          if (isWater(ix, iy)) water = true;
          if (isPushLeft(ix, iy)) push = -1;
          if (isPushRight(ix, iy)) push = 1;
          if (isEnd(ix, iy)) {
            if (currentLevel !== 2) {
              gameMode = 'choose';
            }
            loadLevel((currentLevel + 1) % levels.length);
          }
          const k = ix + iy * L.width;
          if (L.solid[k] >= 20 && L.solid[k] < 32) {
            if ((L.solid[k] % 2) === 1) {
              this.lockedDoor = [ix * tileSize, iy * tileSize];
            }
          }
        }
      }
    }

    let jumpForce = 1;
    if (water) {
      a *= 0.5;
      f *= 0.5;
      jumpForce *= 0.85;
      this.airCharge = Math.min(this.airCharge, 20);
    }

    if (push < 0 || input.left) {
      this.facing = -1;
      this.dx = Math.max(-a, this.dx - f);
    } else if (push > 0 || input.right) {
      this.facing = 1;
      this.dx = Math.min(a, this.dx + f);
    } else if (this.dx < 0) {
      this.dx = Math.min(0, this.dx + f);
    } else if (this.dx > 0) {
      this.dx = Math.max(0, this.dx - f);
    }
    if (this.dy < 0 && !input.jump && this.bounceAni <= 0) {
      this.dy++;
    }
    if (this.bounceAni > 0) {
      this.bounceAni--;
    }
    if (this.air === 0) {
      this.lastAir0 = this.y;
      this.airAni = 0;
    } else {
      this.airAni++;
    }
    if (input.hitJump && this.air <= 5) {
      this.y = this.lastAir0;
      this.bounce(jumpForce, false);
    }
    if (this.player === 'witch') {
      if (this.air > 0 && this.dy >= 0 && this.airCharge > 0) {
        if (input.hitJump && this.air < 100) {
          this.air = 100;
        }
        if (this.air >= 100 && input.jump) {
          this.dy = -this.ddy;
          this.airCharge--;
        }
      }
    }
    if (debug && input.hitStart) {
      if (this.player === 'witch') {
        this.player = 'wolf';
      } else if (this.player === 'wolf') {
        this.player = 'vampire';
      } else {
        this.player = 'witch';
      }
    }
    if (input.hitUp && this.air <= 0) {
      const tx = Math.floor((this.x + this.width / 2) / tileSize);
      const ty = Math.floor(this.y / tileSize);
      if (tx >= 0 && tx < L.width && ty >= 0 && ty < L.height) {
        const k = tx + ty * L.width;
        if (L.solid[k] >= 20 && L.solid[k] < 32) {
          const door = Math.floor((L.solid[k] - 20) / 2);
          const locked = (L.solid[k] % 2) === 1;
          if (!locked || (debug || this.keys > 0)) {
            if (locked) {
              if (!debug) this.keys--;
              const unlockDoors = (lv) => {
                const xy = lv.doors.find(d => d.door === door);
                if (xy) {
                  const k = xy.x + xy.y * lv.width;
                  if (lv.solid[k] & 1) {
                    lv.solid[k]--;
                    lv.world[k]++;
                    lv.world[k + lv.width]++;
                  }
                }
              };
              this.lockedDoor = false;
              unlockDoors(L);
              unlockDoors(LO);
            }
            this.doorAni = 1;
            this.doorTarget = door;
            this.x = tx * tileSize;
            this.y = ty * tileSize;
            this.dx = 0;
            this.dy = 0;
            this.mx = 0;
            this.my = 0;
            this.attack = 0;
            updateDoorTiles(-2);
            return;
          }
        }
      }
    }
    if (this.player === 'wolf' && input.hitSecond && this.attack <= 0) {
      this.attack = 20;
    }
    if (this.attacking()) {
      const ax = this.facing < 0
        ? this.x - this.attackRect[0] - this.attackRect[2]
        : this.x + this.width + this.attackRect[0];
      const ay = this.y + this.attackRect[1];
      const sx = Math.floor(ax / tileSize);
      const ex = Math.floor((ax + this.attackRect[2] - 1) / tileSize);
      const sy = Math.floor(ay / tileSize);
      const ey = Math.floor((ay + this.attackRect[3] - 1) / tileSize);
      const brokeStuff = this.breakBlocks(sx, ex, sy, ey);
      if (brokeStuff > 0) {
        this.brokeAni = 10;
      }
    }
    if (this.brokeAni > 0) {
      this.brokeAni--;
      this.dx = 0;
    }
    if (this.attack > 0) {
      this.attack--;
    }
    if (this.iframes > 0) {
      this.iframes--;
    }
  }

  breakBlocks(sx, ex, sy, ey) {
    let brokeStuff = 0;
    for (let iy = sy; iy <= ey; iy++) {
      if (iy < 0 || iy >= L.height) continue;
      for (let ix = sx; ix <= ex; ix++) {
        if (ix < 0 || ix >= L.width) continue;
        let k = ix + iy * L.width;
        let double = false;
        let spawn = false;
        switch (L.solid[k]) {
          case 7: // break single
            spawn = true;
            brokeStuff++;
            L.world[k] += 2;
            L.solid[k] = 0;
            break;
          case 8: // upper left
            double = true;
            break;
          case 9: // upper right
            double = true;
            k--;
            break;
          case 10: // lower left
            double = true;
            k -= L.width;
            break;
          case 11: // lower right
            double = true;
            k -= L.width + 1;
            break;
        }
        if (double) {
          brokeStuff += 4;
          L.world[k] += 2;
          L.world[k + 1] += 2;
          L.world[k + L.width] += 2;
          L.world[k + L.width + 1] += 2;
          L.solid[k] = 0;
          L.solid[k + 1] = 0;
          L.solid[k + L.width] = 0;
          L.solid[k + L.width + 1] = 0;
        }
        if (spawn || double) {
          spawnParticles('Block', {
            x: ix * tileSize,
            y: iy * tileSize,
            width: (double ? 2 : 1) * tileSize,
            height: (double ? 2 : 1) * tileSize
          });
        }
      }
    }
    return brokeStuff;
  }

  fire(ev, boss) {
    switch (ev) {
      case 'bonk-down': {
        if (this.player === 'witch') {
          this.air = 0;
          this.airCharge = 35;
        } else if (this.player === 'vampire') {
          this.airCharge = 35;
        }
        break;
      }
      case 'bonk-up':
        if (this.player === 'wolf') {
          if (boss && Math.abs(this.y - (boss.y + boss.height)) <= 1) {
            boss.kill();
          } else {
            const y = Math.floor(Math.floor(this.y) / tileSize) - 1;
            this.breakBlocks(
              Math.floor(Math.floor(this.x) / tileSize),
              Math.floor((Math.floor(this.x) + this.width - 1) / tileSize),
              y,
              y
            );
          }
        }
        break;
    }
  }

  draw(cx, cy) {
    const x = typeof cx === 'number' ? Math.floor(this.x) + cx : 74;
    const y = typeof cy === 'number' ? Math.floor(this.y) + cy : 61;

    const drawDoor = (i) => {
      const xy = L.doors.find(d => d.door === this.doorTarget);
      const k = xy.x + xy.y * L.width;
      const t = ((L.world[k] & 0x7ff) + 2) + i;
      const dx = (t % 32) * tileSize;
      const dy = Math.floor(t / 32) * tileSize;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(ic.tiles, dx, dy, tileSize, tileSize * 2, x, y, tileSize, tileSize * 2);
    };

    const di = this.doorAni - 1;
    if (di >= 0 && di < 10) {
      // open door behind
      drawDoor(Math.floor(di / 2));
    } else if (di >= 30 && di < 40) {
      // close door behind
      drawDoor(Math.floor((40 - di) / 2));
    }

    const skipIframe = this.deathAni > 0 || Math.floor(this.iframes / 10) % 2 === 1;

    switch (this.player) {
      case 'witch': {
        const drawWitch = (ix) => {
          if (skipIframe) return;
          if (this.facing < 0) {
            drawImage(ic.sprites, ix, 0, 32, 32, x - 11, y - 4, 4);
          } else {
            drawImage(ic.sprites, ix, 0, 32, 32, x - 10, y - 4, 0);
          }
        };
        if (this.air <= 0) {
          if (Math.floor(this.dx * 1.5) === 0) {
            drawWitch(0);
          } else {
            const frame = Math.floor(Date.now() / 100) % 4;
            drawWitch(frame === 0 ? 32 : frame === 3 ? 96 : 64);
          }
        } else if (this.airAni <= 2) {
          drawWitch(128);
        } else if (this.airAni > 2 && this.dy < 0 && this.dy !== -this.ddy) {
          drawWitch(160);
        } else if (this.airAni > 2 && this.dy === 0) {
          drawWitch(192);
        } else {
          drawWitch(224);
        }
        break;
      }
      case 'wolf': {
        const drawWolf = (ix) => {
          if (skipIframe) return;
          if (this.facing < 0) {
            drawImage(ic.sprites, ix, 64, 32, 32, x - 10, y - 6, 4);
          } else {
            drawImage(ic.sprites, ix, 64, 32, 32, x - 11, y - 6, 0);
          }
        };
        if (this.attacking()) {
          drawWolf(this.attack > 14 ? 256 : 288);
        } else if (this.air <= 0) {
          if (Math.floor(this.dx * 1.5) === 0) {
            drawWolf(0);
          } else {
            const frame = Math.floor(Date.now() / 100) % 4;
            drawWolf(frame === 0 ? 32 : frame === 3 ? 96 : 64);
          }
        } else if (this.airAni <= 2) {
          drawWolf(128);
        } else if (this.airAni > 2 && this.dy < 0) {
          drawWolf(160);
        } else {
          drawWolf(192);
        }

        if (false && debug && this.attacking()) {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = '#ff000077';
          const ar = this.attackingRect();
          ctx.fillRect(cx + ar.x, cy + ar.y, ar.width, ar.height);
        }
        break;
      }
      case 'vampire': {
        const drawVamp = (ix) => {
          if (skipIframe) return;
          if (this.facing < 0) {
            drawImage(ic.sprites, ix, 32, 32, 32, x - 10, y - 4, 4);
          } else {
            drawImage(ic.sprites, ix, 32, 32, 32, x - 11, y - 4, 0);
          }
        };
        if (this.air <= 0) {
          if (Math.floor(this.dx * 1.5) === 0) {
            drawVamp(0);
          } else {
            const frame = Math.floor(Date.now() / 100) % 2;
            drawVamp(frame === 0 ? 32 : 64);
          }
        } else if (this.airAni > 2 && this.dy < 0) {
          drawVamp(96);
        } else {
          drawVamp(128);
        }
        break;
      }
    }

    //ctx.setTransform(1, 0, 0, 1, 0, 0);
    //ctx.fillStyle = '#f00';
    //ctx.fillRect(x, y, this.width, this.height);

    if (di >= 10 && di < 20) {
      // closed door ahead
      drawDoor(Math.floor((20 - di) / 2));
    } else if (di >= 20 && di < 30) {
      drawDoor(0);
    }

    if (this.lockedDoor) {
      drawImage(ic.sprites, 96, 224, 32, 32,
        cx + Math.round(this.lockedDoor[0]) - 11,
        cy + Math.round(this.lockedDoor[1] + Math.sin(Date.now() / 100)) - 33,
        0
      );
    }
  }

  distanceFrom(ent) {
    const ax = this.x + this.width / 2;
    const ay = this.y + this.height / 2;
    const bx = ent.x + ent.width / 2;
    const by = ent.y + ent.height / 2;
    const dx = ax - bx;
    const dy = ay - by;
    return Math.sqrt(dx * dx + dy * dy);
  }

  distanceFromX(ent) {
    const ax = this.x + this.width / 2;
    const bx = ent.x + ent.width / 2;
    return Math.abs(ax - bx);
  }

  distanceFromY(ent) {
    const ay = this.y + this.height / 2;
    const by = ent.y + ent.height / 2;
    return Math.abs(ay - by);
  }

  iframes = 0;
  damage() {
    if (this.deathAni > 0) {
      return;
    }
    if (this.doorAni > 0) {
      return;
    }
    if (this.iframes > 0) {
      return;
    }
    this.hearts--;
    if (this.hearts <= 0) {
      this.deathAni = 140;
      spawnParticles('Player', this);
    } else {
      this.iframes = 120;
    }
  }

  attacking() {
    return this.attack > 10;
  }

  attackingRect() {
    // expand upwards slightly for hitting enemies on higher ledges
    const expand = 3;
    return {
      x: this.facing > 0
        ? Math.floor(this.x) + this.width + this.attackRect[0]
        : Math.floor(this.x) - this.attackRect[0] - this.attackRect[2],
      y: Math.floor(this.y) + this.attackRect[1] - expand,
      width: this.attackRect[2],
      height: this.attackRect[3] + expand
    };
  }

  bounce(m, setBounceAni) {
    let jumpForce = -6;
    if (this.player === 'vampire') {
      this.ddy = 0.06;
      jumpForce = -3.98;
    }
    this.fire('bonk-down');
    this.air = 100;
    this.airAni = 1;
    if (setBounceAni) {
      this.bounceAni = 6;
    }
    this.dy = jumpForce * m;
  }
}

let playerEntity = new UserEntity();
let entities = [playerEntity];
let targetEntity = playerEntity;

class SwampMonsterEntity {
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0.2;
  maxSpeed = [-6.5, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 22;
  air = 0;
  facing = 1;

  state = 'underwater-left';
  underwaterRange = [0, 0];
  jumpFrame = 0;
  jumpForce = -6.5;
  jumpCooloff = 0;
  walkAni = 0;
  swampY = 0;

  constructor(x, y, r, jf) {
    this.x = x;
    this.y = y;
    this.swampY = y + 11;
    this.jumpForce = jf;
    this.underwaterRange = [
      this.x - r * 11,
      this.x
    ];
  }

  think() {
    if (this.state === 'underwater-left') {
      if (this.x > this.underwaterRange[0]) {
        this.dx = -0.3;
      } else {
        this.state = 'underwater-right';
      }
    } else if (this.state === 'underwater-right') {
      if (this.x < this.underwaterRange[1]) {
        this.dx = 0.3;
      } else {
        this.state = 'underwater-left';
      }
    } else if (this.state === 'walk-left') {
      if (this.x > this.underwaterRange[0]) {
        this.dx = -0.5;
      } else {
        this.state = 'walk-right';
      }
    } else if (this.state === 'walk-right') {
      if (this.x < this.underwaterRange[1]) {
        this.dx = 0.5;
      } else {
        this.state = 'walk-left';
      }
    }
    if (this.state.startsWith('underwater-')) {
      // check for player trigger
      if (playerEntity.distanceFromX(this) <= 55) {
        if (this.air <= 0 && this.jumpCooloff <= 0) {
          this.jumpFrame = 0;
          this.dx = 0;
          this.dy = this.jumpForce;
          this.jumpCooloff = 100;
          if (playerEntity.distanceFromY(this) <= Math.abs(this.jumpForce) * 8.46) {
            this.state = 'underwater-jump';
            this.dy *= 0.6;
          } else {
            this.state = 'jump';
          }
        }
      }
    }
    if (this.jumpCooloff > 0) {
      this.jumpCooloff--;
    }
    if (this.state === 'jump' || this.state === 'underwater-jump') {
      this.jumpFrame++;
    }
    if (this.jumpFrame > 10 && this.air <= 0 && this.state === 'underwater-jump') {
      if (playerEntity.x < this.x) {
        this.state = 'underwater-left';
      } else {
        this.state = 'underwater-right';
      }
    }
    if (this.jumpFrame > 10 && this.air <= 0 && this.state === 'jump') {
      if (playerEntity.x < this.x) {
        this.state = 'walk-left';
      } else {
        this.state = 'walk-right';
      }
    }
    this.walkAni += Math.abs(this.dx);
  }

  fire(ev) {
    switch (ev) {
      case 'bonk-down':
        this.air = 0;
        break;
    }
  }

  kill() {
    this.alive = false;
    playerEntity.score += 100;
    spawnParticles('SwampMonster', this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    const draw = (ix) => {
      if (this.dx <= 0) {
        drawImage(ic.sprites, ix * 32, 96, 32, 32, x - 11, y - 4, 4);
      } else {
        drawImage(ic.sprites, ix * 32, 96, 32, 32, x - 10, y - 4, 0);
      }
    };
    const drawHead = (ix) => {
      const hs = 2;
      if (this.dx <= 0) {
        drawImage(ic.sprites, ix * 32, 96, 32, hs + 4, x - 11, y - 4 - hs, 4);
      } else {
        drawImage(ic.sprites, ix * 32, 96, 32, hs + 4, x - 10, y - 4 - hs, 0);
      }
    };
    if (this.y < this.swampY) {
      draw(Math.floor(this.walkAni / 4) % 4);
    } else {
      drawHead(Math.floor(this.walkAni / 4) % 4);
    }

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText(this.state, x, y);
    }
  }
}

class ZombieMonsterEntity {
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0.2;
  maxSpeed = [-6.5, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 22;
  air = 0;
  facing = 1;

  state = 'underground';
  jumpForce = -3.5;
  walkFrame = 0;
  jumpCooloff = 0;
  autojump = false;
  walkAni = 0;

  constructor(x, y, onKill, autojump) {
    this.x = x;
    this.y = y;
    this.onKill = onKill || (() => {});
    this.autojump = autojump;
  }

  think() {
    const mag = (1 - Math.cos(this.walkFrame * Math.PI * 2 / 60)) * 0.5;
    if (this.state === 'left' || this.state === 'right') {
      if (this.state === 'left') {
        this.walkFrame++;
        this.dx = -mag * 0.4;
      } else if (this.state === 'right') {
        this.walkFrame++;
        this.dx = mag * 0.4;
      }
      if (this.walkFrame === 60) {
        if (playerEntity.x < this.x) {
          this.state = 'left';
          this.walkFrame = 0;
        } else {
          this.state = 'right';
          this.walkFrame = 0;
        }
      }
      if (this.jumpCooloff > 0) {
        this.jumpCooloff--;
      } else if (
        playerEntity.distanceFromX(this) >= 17 &&
        playerEntity.distanceFromX(this) <= 39 &&
        playerEntity.y + playerEntity.height + 1 < this.y &&
        this.air <= 0 &&
        (this.walkFrame <= 5 || this.walkFrame >= 55) &&
        Math.random() < 0.5
      ) {
        this.jumpCooloff = 100;
        this.state = 'jump';
        this.dy = this.jumpForce;
      }
    } else if (this.state === 'underground') {
      // check for player trigger
      if (this.autojump || (
        playerEntity.distanceFromY(this) <= 77 &&
        playerEntity.distanceFromX(this) <= 55
      )) {
        this.state = 'jump';
        this.dy = this.jumpForce;
      }
    }
    this.walkAni += Math.abs(this.dx);
  }

  fire(ev) {
    if (ev === 'bonk-down') {
      this.air = 0;
      if (this.state === 'jump') {
        if (playerEntity.x < this.x) {
          this.state = 'left';
          this.walkFrame = 0;
        } else {
          this.state = 'right';
          this.walkFrame = 0;
        }
      }
    } else if (ev === 'bonk-left' && this.state === 'left') {
      this.state = 'right';
    } else if (ev === 'bonk-right' && this.state === 'right') {
      this.state = 'left';
    }
  }

  kill() {
    this.onKill();
    this.alive = false;
    playerEntity.score += 100;
    spawnParticles('ZombieMonster', this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    const draw = (ix) => {
      if (this.state === 'right') {
        drawImage(ic.sprites, ix * 32, 128, 32, 32, x - 10, y - 4, 0);
      } else {
        drawImage(ic.sprites, ix * 32, 128, 32, 32, x - 12, y - 4, 4);
      }
    };
    draw(Math.floor(this.walkAni / 4) % 3);

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText(this.state, x, y);
    }
  }
}

class WalkMonsterEntity {
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0.2;
  maxSpeed = [-5, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 11;
  air = 0;
  facing = 0;
  walkAni = 0;

  state = 'sleep';

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  think() {
    if (this.state === 'left') {
      this.dx = -0.3;
    } else if (this.state === 'right') {
      this.dx = 0.3;
    } else if (this.state === 'sleep') {
      if (playerEntity.distanceFrom(this) < 110) {
        if (playerEntity.x < this.x) {
          this.state = 'left';
        } else {
          this.state = 'right';
        }
      }
    }
    this.walkAni += Math.abs(this.dx);
  }

  fire(ev) {
    if (ev === 'bonk-left' && this.state === 'left') {
      this.state = 'right';
    } else if (ev === 'bonk-right' && this.state === 'right') {
      this.state = 'left';
    }
  }

  kill() {
    this.alive = false;
    playerEntity.score += 20;
    spawnParticles('WalkMonster', this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    const draw = (ix) => {
      if (this.dx <= 0) {
        drawImage(ic.sprites, (4 + ix) * 32, 96, 32, 32, x - 10, y - 10, 4);
      } else {
        drawImage(ic.sprites, (4 + ix) * 32, 96, 32, 32, x - 11, y - 10, 0);
      }
    };
    draw(Math.floor(this.walkAni / 4) % 3);

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText(this.state, x, y);
    }
  }
}

class GhostMonsterEntity {
  skipPhysics = true;
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0;
  maxSpeed = [-5, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 11;
  air = 0;
  facing = 0;

  angle = 0;
  startX = 0;
  startY = 0;
  radX = 0;
  radY = 0;
  speed = 0.02;

  constructor(x, y, w, h, radX, radY, speed) {
    this.x = x;
    this.y = y;
    this.width = w;
    this.height = h;
    this.startX = x;
    this.startY = y - radY * 11;
    this.radX = radX * 11;
    this.radY = radY * 11;
    this.speed = speed;
  }

  think() {
    const x = Math.floor(this.startX + this.radX * Math.sin(this.angle));
    const y = Math.floor(this.startY + this.radY * Math.cos(this.angle));
    const dx = x - this.x;
    const dy = y - this.y;
    if (dx !== 0) {
      this.dx = dx;
    }
    if (dy !== 0) {
      this.dy = dy;
    }
    this.x = x;
    this.y = y;
    this.angle -= this.speed;
    if (this.angle < 0) {
      this.angle += Math.PI * 2;
    }
  }

  fire(ev) {}

  kill() {
    this.alive = false;
    playerEntity.score += 50;
    spawnParticles('GhostMonster' + this.width, this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    const drawUFO = (ix) => {
      drawImage(ic.sprites, (3 + ix) * 32, 128, 32, 32, x - 6, y - 7, 0);
    };
    const drawOrb = (ix) => {
      drawImage(ic.sprites, (7 + ix) * 32, 128, 32, 32, x - 9, y - 10, 0);
    };
    if (this.width === 21) {
      drawUFO(Math.floor(Date.now() / 100) % 4);
    } else {
      drawOrb(Math.floor(Date.now() / 100) % 4);
    }

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText('' + this.dy, x, y);
    }
  }
}

class HiddenMonsterEntity {
  skipDamage = true;
  alive = true;
  x = 385;
  y = 242;
  homeX = 0;
  homeY = 0;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0;
  maxSpeed = [-5, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 22;
  air = 0;
  facing = 0;
  walkAni = 0;

  state = 'hidden';

  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.homeX = x;
    this.homeY = y;
  }

  think() {
    if (this.state === 'hidden') {
      // do nothing
    } else if (this.state === 'wait') {
      if (playerEntity.distanceFromX(this) >= 33) {
        this.skipDamage = false;
        if (playerEntity.x < this.x) {
          this.state = 'left';
        } else {
          this.state = 'right';
        }
      }
    } else if (this.state === 'left') {
      this.dx = -1;
    } else if (this.state === 'right') {
      this.dx = 1;
    } else if (this.state === 'dead') {
      this.dx = 0;
    }
    this.walkAni += Math.abs(this.dx);
  }

  fire(ev) {
    if (ev === 'touch') {
      if (this.state === 'hidden') {
        this.state = 'wait';
      }
    } else if (this.state === 'left' && ev === 'bonk-left') {
      this.state = 'right';
    } else if (this.state === 'right' && ev === 'bonk-right') {
      this.state = 'left';
    }
  }

  kill() {
    if (this.state !== 'dead') {
      this.skipDamage = true;
      this.state = 'dead';
      playerEntity.score += 100;
      spawnParticles('HiddenMonster', this);
    }
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;
    const hx = Math.floor(this.homeX) + cx;
    const hy = Math.floor(this.homeY) + cy;

    const drawPainting = (ix) => {
      drawImage(ic.sprites, (6 + ix) * 32, 160, 32, 32, hx - 11, hy - 20, 0);
    }
    const drawClown = (ix) => {
      if (this.dx <= 0) {
        drawImage(ic.sprites, ix * 32, 192, 32, 32, x - 10, y - 6, 4);
      } else {
        drawImage(ic.sprites, ix * 32, 192, 32, 32, x - 10, y - 6, 0);
      }
    };
    const dx = playerEntity.x + playerEntity.width / 2 - this.homeX - this.width / 2;
    if (this.state === 'hidden' || this.state === 'wait') {
      if (dx < -11) drawPainting(0);
      else if (dx <= 11) drawPainting(1);
      else drawPainting(2);
    } else {
      drawPainting(3);
      if (this.state !== 'dead') {
        drawClown(Math.floor(this.walkAni / 10) % 4);
      }
    }

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = this.skipDamage ? '#00ffff77' : '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText('' + this.dy, x, y);
    }
  }
}

class PieMonsterEntity {
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = -0.5;
  ddx = 0;
  ddy = 0.01;
  maxSpeed = [-5, 5];
  mx = 0;
  my = 0;
  width = 8;
  height = 13;
  air = 0;
  facing = 0;

  constructor(x, y, dir) {
    this.x = x;
    this.y = y;
    this.facing = dir;
    this.dx = dir * Math.max(0.5, Math.min(1, lerp(0.5, 1,
      Math.abs(playerEntity.x - this.x) / 110)));
    this.dy = -Math.max(0.4, Math.min(1.2, lerp(0.4, 1.2,
      (this.y - playerEntity.y) / 88)));
  }

  think() {}

  fire(ev) {
    this.kill();
  }

  kill() {
    this.alive = false;
    spawnParticles('PieMonster', this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    const draw = (ix) => {
      if (this.facing <= 0) {
        drawImage(ic.sprites, (3 + ix) * 32, 160, 32, 32, x - 12, y - 10, 4);
      } else {
        drawImage(ic.sprites, (3 + ix) * 32, 160, 32, 32, x - 12, y - 10, 0);
      }
    };
    draw(Math.floor(Date.now() / 200) % 3);

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText('' + this.dy, x, y);
    }
  }
}

class ThrowMonsterEntity {
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0;
  maxSpeed = [-5, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 22;
  air = 0;
  facing = 0;

  state = 'sleep';
  timeout = 90;

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  think() {
    this.facing = playerEntity.x < this.x ? -1 : 1;
    if (this.state === 'sleep') {
      if (playerEntity.distanceFromX(this) <= 110) {
        this.state = 'throw';
      }
    } else {
      if (this.timeout > 0) {
        this.timeout--;
      } else {
        this.timeout = 140 + Math.floor(80 * Math.random());
        entities.push(new PieMonsterEntity(
          this.x + (this.facing > 0 ? 11 - 6 : 0),
          this.y + 6,
          this.facing
        ));
      }
    }
  }

  fire(ev) {}

  kill() {
    this.alive = false;
    playerEntity.score += 100;
    spawnParticles('ThrowMonster', this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    const draw = (ix) => {
      if (this.facing <= 0) {
        drawImage(ic.sprites, ix * 32, 160, 32, 32, x - 11, y - 5, 4);
      } else {
        drawImage(ic.sprites, ix * 32, 160, 32, 32, x - 10, y - 5, 0);
      }
    };
    if (this.timeout > 120) {
      draw(1);
    } else if (this.timeout > 67) {
      draw(2);
    } else {
      draw(0);
    }

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText('' + this.dy, x, y);
    }
  }
}

class DripMonsterEntity {
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0;
  maxSpeed = [-5, 5];
  mx = 0;
  my = 0;
  width = 22;
  height = 22;
  air = 0;
  facing = 0;
  walkAni = 0;

  state = 'sleep';

  constructor(x, y, onKill) {
    this.x = x;
    this.y = y;
    this.onKill = onKill || (() => {});
  }

  think() {
    if (this.state === 'left') {
      this.dx = -0.3;
    } else if (this.state === 'right') {
      this.dx = 0.3;
    } else if (this.state === 'sleep') {
      if (playerEntity.y > this.y && playerEntity.distanceFromX(this) < 55) {
        this.state = 'drop';
        this.ddy = 0.25;
      }
    }
    this.walkAni += Math.abs(this.dx);
  }

  fire(ev) {
    if (ev === 'bonk-left' && this.state === 'left') {
      this.state = 'right';
    } else if (ev === 'bonk-right' && this.state === 'right') {
      this.state = 'left';
    } else if (this.state === 'drop' && ev === 'bonk-down') {
      if (playerEntity.x < this.x) {
        this.state = 'left';
      } else {
        this.state = 'right';
      }
    }
  }

  kill() {
    this.onKill();
    this.alive = false;
    playerEntity.score += 50;
    spawnParticles('DripMonster', this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    const draw = (ix, inv) => {
      if (this.dx <= 0) {
        drawImage(ic.sprites, (7 + ix) * 32, 96, 32, 32, x - 2, y - 4, inv ? 6 : 4);
      } else {
        drawImage(ic.sprites, (7 + ix) * 32, 96, 32, 32, x - 8, y - 4, inv ? 2 : 0);
      }
    };
    if (this.state === 'sleep') {
      draw(3);
    } else if (this.state === 'drop') {
      draw(3, true);
    } else {
      draw(Math.floor(this.walkAni / 4) % 3);
    }

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText(this.state, x, y);
    }
  }
}

class BatMonsterEntity {
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0;
  maxSpeed = [-5, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 11;
  air = 0;
  facing = 0;

  state = 'sleep';

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  think() {
    const sp = 0.8;
    if (this.state === 'left') {
      this.facing = -1;
      if (this.dy < 0) {
        this.ddy = 0;
        this.dy = 0;
      }
      this.dx = -sp;
    } else if (this.state === 'right') {
      this.facing = 1;
      if (this.dy < 0) {
        this.ddy = 0;
        this.dy = 0;
      }
      this.dx = sp;
    } else if (this.state === 'sleep') {
      this.facing = 0;
      if (playerEntity.y > this.y && playerEntity.distanceFromX(this) < 55) {
        this.ddy = -0.05;
        this.dy = 1.86;
        if (playerEntity.x < this.x) {
          this.state = 'left';
          this.dx = -sp;
        } else {
          this.state = 'right';
          this.dx = sp;
        }
      }
    } else if (this.state === 'wait') {
      if (playerEntity.distanceFrom(this) < 55) {
        if (playerEntity.x < this.x) {
          this.state = 'left';
          this.dx = -sp;
        } else {
          this.state = 'right';
          this.dx = sp;
        }
      }
    }
  }

  fire(ev) {
    if (ev === 'bonk-left' && this.state === 'left') {
      this.state = 'wait';
      this.facing = 1;
    } else if (ev === 'bonk-right' && this.state === 'right') {
      this.state = 'wait';
      this.facing = -1;
    }
  }

  kill() {
    this.alive = false;
    playerEntity.score += 50;
    spawnParticles('BatMonster', this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    if (this.state === 'sleep') {
      drawImage(ic.sprites, 160, 192, 32, 32, x - 10, y - 10, 0);
    } else if (this.facing <= 0) {
      drawImage(ic.sprites, 128, 192, 32, 32, x - 11, y - 10, 4);
    } else {
      drawImage(ic.sprites, 128, 192, 32, 32, x - 10, y - 10, 0);
    }

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText(this.state, x, y);
    }
  }
}

class HandMonsterEntity {
  skipPhysics = true;
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0;
  maxSpeed = [-2, 2];
  mx = 0;
  my = 0;
  width = 11;
  height = 32;
  air = 0;
  facing = 0;
  timer1 = 100;

  constructor(x, y, dir) {
    this.x = x;
    this.y = y + 1;
    this.facing = dir;
    this.dx = this.facing * 0.8;
    this.ddx = this.facing * 0.05;
  }

  think() {
    if (this.skipPhysics) {
      if (this.timer1 > 0) {
        this.timer1--;
        this.y = Math.max(463, Math.min(518, playerEntity.y - 4));
        if (this.facing > 0) {
          this.x = Math.floor(cameraX);
        } else {
          this.x = Math.floor(cameraX + 160 - this.width + 1);
        }
      } else {
        this.skipPhysics = false;
      }
    }
  }

  fire(ev) {
    if (ev === 'bonk-left' || ev === 'bonk-right' || ev === 'damage') {
      this.kill();
    }
  }

  kill() {
    this.alive = false;
    spawnParticles('HandMonster', this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    if (this.facing <= 0) {
      drawImage(ic.sprites, 0, 256, 12, 34, x - 2, y - 1, 4);
    } else {
      drawImage(ic.sprites, 0, 256, 12, 34, x - 1, y - 1, 0);
    }

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
    }
    //ctx.fillText('' + this.dy, x, y);
  }
}

class BallMonsterEntity {
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0;
  maxSpeed = [-5, 5];
  mx = 0;
  my = 0;
  width = 11;
  height = 11;
  air = 0;
  facing = 0;

  constructor(x, y, speed) {
    this.x = x;
    this.y = y;
    const ang = Math.atan2(playerEntity.y - y, playerEntity.x - x);
    this.dx = speed * Math.cos(ang);
    this.dy = speed * Math.sin(ang);
  }

  think() {}

  fire(ev) {
    this.kill();
  }

  kill() {
    this.alive = false;
    spawnParticles('BallMonster', this);
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;

    drawImage(ic.sprites, 16, 256, 13, 13, x - 1, y - 1, 0);

    if (debug) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#00ff0077';
      ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText('' + this.dy, x, y);
    }
  }
}

class BossMonsterEntity {
  isSolid = true;
  skipDamage = false;
  skipHurtPlayer = true;
  skipPhysics = true;
  alive = true;
  x = 385;
  y = 242;
  dx = 0;
  dy = 0;
  ddx = 0;
  ddy = 0;
  maxSpeed = [-6.5, 5];
  mx = 0;
  my = 0;
  width = 27;
  height = 27;
  air = 0;
  facing = 1;

  first = true;
  state = 'fadeIn';
  timer1 = 600;
  baddieType = 1;
  baddieCount = 0;
  tile = -1;
  shots = 0;
  shotGroups = 0;
  health = 3;
  nextHand = 0;
  noseAni = 0;
  candy = 1000;

  constructor(x, y) {
    this.x = x + 3;
    this.y = y + 3;
    this.hideNose();
  }

  hp() {
    return this.health / 5;
  }

  think() {
    if (this.isSolid) {
      this.noseAni++;
    }
    switch (this.state) {
      case 'fadeIn': {
        if (this.timer1 > 0) {
          if (playerEntity.y >= 473) {
            vclampCamera = true;
          }
          this.timer1--;
          if (this.timer1 === 120) {
            this.tile = 0;
          } else if (this.timer1 === 60) {
            this.tile = 1;
          }
        } else {
          this.tile = 4;
          this.first = false;
          this.state = 'intro';
          this.timer1 = 120;
        }
        break;
      }
      case 'intro': {
        if (this.timer1 > 0) {
          this.timer1--;
        } else {
          this.timer1 = 60;
          this.startShots();
        }
        break;
      }
      case 'shoot': {
        if (this.timer1 > 0) {
          this.timer1--;
        } else {
          if (this.shots < 3) {
            if (this.shots === 0) {
              this.noseAni = 0;
            }
            this.tile = 3;
            this.spawnBall(lerp(2, 1, this.hp()));
            this.timer1 = 60;
          } else {
            this.tile = 2;
            this.shots = 0;
            this.timer1 = 180;
            this.shotGroups++;
            this.noseAni = 0;
            if (this.shotGroups >= 3) {
              this.startFadeOut(120);
            }
          }
        }
        break;
      }
      case 'fadeOut': {
        if (this.timer1 > 0) {
          this.timer1--;
          if (this.timer1 === 120) {
            this.tile = 1;
          } else if (this.timer1 === 60) {
            this.tile = 0;
          }
        } else {
          this.tile = -1;
          this.timer1 = 180;
          this.baddieType = 1 - this.baddieType;
          this.state = 'baddies';
        }
        break;
      }
      case 'baddies': {
        if (this.timer1 > 0) {
          this.timer1--;
          if (this.timer1 === 120) {
            this.baddieCount = this.baddieType === 1 ? 3 : 2;
            this.spawnBaddie(lerp(0.1, 0.4, Math.random()));
          } else if (this.timer1 === 60) {
            if (this.baddieType === 1) {
              this.spawnBaddie(lerp(0.4, 0.6, Math.random()));
            }
          } else if (this.timer1 === 0) {
            this.spawnBaddie(lerp(0.6, 0.9, Math.random()));
            this.state = 'baddies-wait';
          }
        }
        break;
      }
      case 'baddies-wait': {
        // wait for baddies to die
        break;
      }
      case 'hands': {
        if (this.timer1 > 0) {
          this.timer1--;
          if (
            this.timer1 === 180 ||
            this.timer1 === 60
          ) {
            this.spawnHand();
          }
        } else {
          this.startFadeOut();
        }
        break;
      }
      case 'dead': {
        if (this.timer1 > 0) {
          this.timer1--;
        } else if (this.candy > 0) {
          this.candy--;
          if ((this.candy % 10) === 0) {
            const dir = (this.candy % 20) === 0 ? -1 : 1;
            const item = new ItemEntity(
              dir < 0 ? this.x + 118 : this.x - 102,
              this.y, 'coin', -1);
            item.launch(dir * lerp(1, 3, Math.random()), lerp(-4, -6, Math.random()));
            entities.push(item);
          }
        } else {
          theEnd = true;
        }
        break;
      }
    }
  }

  startShots() {
    this.tile = 2;
    this.showNose();
    this.shots = 0;
    this.shotGroups = 0;
    this.timer1 = 0;
    this.state = 'shoot';
  }

  startHands() {
    this.tile = 4;
    this.hideNose();
    this.timer1 = 360;
    this.nextHand = Math.random() < 0.5 ? 1 : 0;
    this.state = 'hands';
  }

  startFadeOut() {
    this.timer1 = 240;
    this.state = 'fadeOut';
    this.tile = 4;
    this.hideNose();
  }

  fire(ev) {
  }

  spawnBall(speed) {
    this.shots++;
    entities.push(new BallMonsterEntity(this.x + 8, this.y + 33, speed));
  }

  spawnHand() {
    this.nextHand = 1 - this.nextHand;
    let y = Math.round(Math.min(this.y + 41, playerEntity.y - 6) / tileSize);
    if (y <= 42) {
      y = 42;
    } else if (y <= 45) {
      y = 44;
    } else {
      y = 47;
    }
    if (this.nextHand === 0) {
      entities.push(new HandMonsterEntity(this.x - 102, y * tileSize, 1));
    } else {
      entities.push(new HandMonsterEntity(this.x + 118, y * tileSize, -1));
    }
  }

  killedBaddie() {
    this.baddieCount--;
    if (this.baddieCount <= 0) {
      this.state = 'fadeIn';
      this.timer1 = 180;
    }
  }

  spawnBaddie(xf) {
    let x = Math.floor(lerp(this.x - 91, this.x + 96, xf));
    const minDist = this.baddieType === 0 ? 11 : 22;
    const bw = this.baddieType === 0 ? 22 : 11;
    if (playerEntity.distanceFromX({ x, width: bw }) <= minDist) {
      x = playerEntity.x + playerEntity.width / 2 +
        (Math.random() < 0.5 ? -1 : 1) * (minDist + bw / 2);
    }
    x = Math.max(this.x - 91, Math.min(this.x + 96, Math.floor(x)));
    entities.push(
      this.baddieType === 0
      ? new DripMonsterEntity(x, this.y - 69, () => this.killedBaddie())
      : new ZombieMonsterEntity(x, this.y + 74, () => this.killedBaddie(), true)
    );
  }

  showNose() {
    this.skipDamage = false;
    this.skipHurtPlayer = true;
    this.isSolid = true;
    this.noseAni = 0;
  }

  hideNose() {
    this.skipDamage = true;
    this.skipHurtPlayer = true;
    this.isSolid = false;
  }

  kill() {
    if (this.state === 'dead') {
      return;
    }
    playerEntity.score += 1000;
    this.health--;
    if (this.health <= 0) {
      this.tile = 5;
      this.timer1 = 300;
      this.state = 'dead';
      invincible = true;
    } else {
      this.startHands();
    }
  }

  draw(cx, cy) {
    const x = Math.floor(this.x) + cx;
    const y = Math.floor(this.y) + cy;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    if (this.tile >= 0) {
      const tx = (this.tile % 3) * 143;
      const ty = Math.floor(this.tile / 3) * 99;
      ctx.drawImage(ic.boss, tx, ty, 143, 99, x - 58, y - 36, 143, 99);
      if (this.isSolid) {
        const t = Math.min(4, Math.floor(this.noseAni / 4));
        ctx.drawImage(ic.sprites, 192 + 32 * t, 192, 32, 32, x - 2, y - 2, 32, 32);
      }
    }
    if (debug) {
      //ctx.fillStyle = (this.skipHurtPlayer ? '#00ffff' : '#00ff00') +
      //  (this.isSolid ? 'aa' : '55');
      //ctx.fillRect(x, y, this.width, this.height);
      //ctx.fillText(this.state + ' ' + this.timer1, x, y);
    }
  }
}

const tileSize = 11;
const enableGamepadSel = document.getElementById('enableGamepad');
enableGamepadSel.selectedIndex = 0;
enableGamepadSel.addEventListener('input', function(){
  enableGamepad = this.options[this.selectedIndex].value === 'true';
});
const musicVol = document.getElementById('musicVol');
musicVol.selectedIndex = 2;
const sfxVol = document.getElementById('sfxVol');
sfxVol.selectedIndex = 2;

function mod(a, b) {
  a = Math.floor(a);
  return a < 0 ? ((a % b) + b) % b : a % b;
}

function drawImage(img, ix, iy, w, h, x, y, flip) {
  switch (flip){
    case 0:
      ctx.setTransform(
        1, 0,
        0, 1,
        x, y
      );
      break;
    case 1:
      ctx.setTransform(
        0, 1,
        1, 0,
        x, y
      );
      break;
    case 2:
      ctx.setTransform(
        1, 0,
        0, -1,
        x, y + h
      );
      break;
    case 3:
      ctx.setTransform(
        0, -1,
        1, 0,
        x, y + h
      );
      break;
    case 4:
      ctx.setTransform(
        -1, 0,
        0, 1,
        x + w, y
      );
      break;
    case 5:
      ctx.setTransform(
        0, 1,
        -1, 0,
        x + w, y
      );
      break;
    case 6:
      ctx.setTransform(
        -1, 0,
        0, -1,
        x + w, y + h
      );
      break;
    case 7:
      ctx.setTransform(
        0, -1,
        -1, 0,
        x + w, y + h
      );
      break;
  }
  ctx.drawImage(img, ix, iy, w, h, 0, 0, w, h);
}

function drawTile(d, x, y){
  const flip = (d >> 12) & 7;
  d = d & 0x7ff;
  const ix = (d & 31) * tileSize;
  const iy = ((d >> 5) & 63) * tileSize;
  drawImage(ic.tiles, ix, iy, tileSize, tileSize, x, y, flip);
}

function tickStart() {
  const btn = (gp, i) =>
    gp && gp.buttons && gp.buttons.length > i && gp.buttons[i].pressed;
  const oldGamepad = {
    jump: gamepad.jump,
    second: gamepad.second,
    start: gamepad.start,
    up: gamepad.up
  };
  gamepad.jump = false;
  gamepad.second = false;
  gamepad.start = false;
  gamepad.up = false;
  gamepad.down = false;
  gamepad.left = false;
  gamepad.right = false;
  if (enableGamepad) {
    for (const gp of navigator.getGamepads()){
      if (btn(gp, gpButton.jump  )){ gamepad.jump   = true; gamepad.hitJump   = !oldGamepad.jump;   }
      if (btn(gp, gpButton.second)){ gamepad.second = true; gamepad.hitSecond = !oldGamepad.second; }
      if (btn(gp, gpButton.start )){ gamepad.start  = true; gamepad.hitStart  = !oldGamepad.start;  }
      if (btn(gp, gpButton.up    )){ gamepad.up     = true; gamepad.hitUp     = !oldGamepad.up;     }
      if (btn(gp, gpButton.right )){ gamepad.right  = true; gamepad.hitRight  = !oldGamepad.right   }
      if (btn(gp, gpButton.down  )){ gamepad.down   = true; gamepad.hitDown   = !oldGamepad.down    }
      if (btn(gp, gpButton.left  )){ gamepad.left   = true; gamepad.hitLeft   = !oldGamepad.left    }
    }
  } else {
    gamepad.hitJump = false;
    gamepad.hitSecond = false;
    gamepad.hitStart = false;
    gamepad.hitUp = false;
    gamepad.hitRight = false;
    gamepad.hitDown = false;
    gamepad.hitLeft = false;
  }
  for (const k of [
    'jump', 'hitJump', 'second', 'hitSecond', 'start', 'hitStart', 'up', 'down', 'left', 'right',
    'hitUp', 'hitRight', 'hitDown', 'hitLeft'
  ]) {
    input[k] = keyboard[k] || gamepad[k];
  }
}

function tickEnd() {
  keyboard.hitStart = false;
  keyboard.hitJump = false;
  keyboard.hitSecond = false;
  keyboard.hitUp = false;
  keyboard.hitRight = false;
  keyboard.hitDown = false;
  keyboard.hitLeft = false;
  redraw();
}

function isSolid(tx, ty, dx, dy) {
  if (tx < 0 || tx >= L.width || ty >= L.height) {
    return true;
  }
  if (ty < 0) {
    ty = 0;
  }
  const t = L.solid[tx + ty * L.width];
  return (
    (t >= 6 && t <= 11) ||
    (dx === 1 && t === 5) ||
    (dx === -1 && t === 3) ||
    (dy === 1 && t === 2) ||
    (dy === -1 && t === 4)
  );
}

function isWater(tx, ty) {
  if (tx < 0 || tx >= L.width || ty < 0 || ty >= L.height) {
    return false;
  }
  const t = L.solid[tx + ty * L.width];
  return t === 12;
}

function isPushLeft(tx, ty) {
  if (tx < 0 || tx >= L.width || ty < 0 || ty >= L.height) {
    return false;
  }
  const t = L.solid[tx + ty * L.width];
  return t === 16;
}

function isPushRight(tx, ty) {
  if (tx < 0 || tx >= L.width || ty < 0 || ty >= L.height) {
    return false;
  }
  const t = L.solid[tx + ty * L.width];
  return t === 15;
}

function isEnd(tx, ty) {
  if (tx < 0 || tx >= L.width || ty < 0 || ty >= L.height) {
    return false;
  }
  const t = L.solid[tx + ty * L.width];
  return t === 17;
}

function isSolidUp(x, width, y, boss) {
  if (boss && boss.isSolid) {
    if (entityOverlap({ x, y: y - 1, width, height: 1 }, boss)) {
      return true;
    }
  }
  if (mod(y, tileSize) === 0) {
    const sx = Math.floor(x / tileSize);
    const ex = Math.floor((x + width - 1) / tileSize);
    const iy = Math.floor(y / tileSize) - 1;
    for (let ix = sx; ix <= ex; ix++) {
      if (isSolid(ix, iy, 0, -1)) {
        return true;
      }
    }
  }
  return false;
}

function isSolidRight(y, height, x, boss) {
  if (boss && boss.isSolid) {
    if (entityOverlap({ x: x + 1, y, width: 1, height }, boss)) {
      return true;
    }
  }
  if (mod(x, tileSize) === tileSize - 1) {
    const sy = Math.floor(y / tileSize);
    const ey = Math.floor((y + height - 1) / tileSize);
    const ix = Math.floor(x / tileSize) + 1;
    for (let iy = sy; iy <= ey; iy++) {
      if (isSolid(ix, iy, 1, 0))
        return true;
    }
  }
  return false;
}

function isSolidDown(x, width, y) {
  if (mod(y, tileSize) === tileSize - 1) {
    const sx = Math.floor(x / tileSize);
    const ex = Math.floor((x + width - 1) / tileSize);
    const iy = Math.floor(y / tileSize) + 1;
    for (let ix = sx; ix <= ex; ix++) {
      if (isSolid(ix, iy, 0, 1)) {
        return true;
      }
    }
  }
  return false;
}

function isSolidLeft(y, height, x, boss) {
  if (boss && boss.isSolid) {
    if (entityOverlap({ x: x - 1, y, width: 1, height }, boss)) {
      return true;
    }
  }
  if (mod(x, tileSize) === 0) {
    const sy = Math.floor(y / tileSize);
    const ey = Math.floor((y + height - 1) / tileSize);
    const ix = Math.floor(x / tileSize) - 1;
    for (let iy = sy; iy <= ey; iy++) {
      if (isSolid(ix, iy, -1, 0))
        return true;
    }
  }
  return false;
}

function tick() {
  if (gameMode === 'title') {
    if (input.hitJump || input.hitStart) {
      gameMode = 'choose';
    }
    return;
  } else if (gameMode === 'choose') {
    const choices = ['witch', 'vampire', 'wolf'];
    const i = choices.indexOf(playerEntity.player);
    if (input.hitLeft && i > 0) {
      playerEntity.player = choices[i - 1];
    } else if (input.hitRight && i < choices.length - 1) {
      playerEntity.player = choices[i + 1];
    }
    if (input.hitJump || input.hitStart) {
      gameMode = 'game';
    }
    return;
  }
  // otherwise, game

  // prune dead entities
  for (let i = 0; i < entities.length; i++) {
    if (!entities[i].alive) {
      entities.splice(i, 1);
      i--;
    }
  }

  // think
  for (const e of entities) {
    if (!e.alive) continue;
    e.think();
    if (!e.skipOverlap && e !== playerEntity) {
      if (e.skipDamage) {
        if (entityOverlap(e, playerEntity)) {
          e.fire('touch');
        }
      } else if (playerEntity.attacking()) {
        if (
          entityOverlap(e, playerEntity) ||
          entityOverlap(e, playerEntity.attackingRect())
        ) {
          e.kill();
        }
      } else if (entityOverlap(e, playerEntity)) {
        if (
          'lastY' in playerEntity &&
          'lastY' in e
        ) {
          const feet = playerEntity.y + playerEntity.height - e.y;
          const air = playerEntity.air;
          const pdy = playerEntity.y - playerEntity.lastY;
          const edy = e.y - e.lastY;
          if (( // if you're moving down and they're moving up or stationary
            air > 0 &&
            pdy > 0 &&
            edy <= 0 &&
            feet > 0 && feet < 11
          ) || ( // if you're floating and they're moving up
            playerEntity.player === 'witch' &&
            air > 0 &&
            pdy >= 0 &&
            edy < 0 &&
            feet > 0 && feet < 11
          )) {
            e.kill();
            playerEntity.bounce(1, true);
          } else if (!e.skipHurtPlayer && !invincible) {
            console.log({ air, pdy, edy, feet });
            e.fire('damage');
            playerEntity.damage();
          }
        }
      }
    }
  }

  // physics
  const bossEntity = entities.find(e => e instanceof BossMonsterEntity);
  for (const e of entities) {
    e.x = Math.floor(e.x);
    e.y = Math.floor(e.y);
    e.lastX = e.x;
    e.lastY = e.y;
    if (!e.alive) continue;
    if (e.skipPhysics) continue;
    const boss = e === playerEntity ? bossEntity : null;
    e.dx = Math.max(e.maxSpeed[0], Math.min(e.maxSpeed[1], e.dx + e.ddx));
    e.dy = Math.max(e.maxSpeed[0], Math.min(e.maxSpeed[1], e.dy + e.ddy));
    e.mx += e.dx;
    e.my += e.dy;
    while (true) {
      let doneX = false;
      if (e.mx >= 1) {
        // can we move 1 pixel right?
        if (isSolidRight(e.y, e.height, e.x + e.width - 1, boss)) {
          // hit wall
          const odx = e.dx;
          e.mx = 0;
          e.dx = 0;
          doneX = true;
          e.fire('bonk-right', odx);
        } else {
          e.x++;
          e.mx--;
        }
      } else if (e.mx < 0) {
        // can we move 1 pixel left?
        if (isSolidLeft(e.y, e.height, e.x, boss)) {
          // hit wall
          const odx = e.dx;
          e.mx = 0;
          e.dx = 0;
          doneX = true;
          e.fire('bonk-left', odx);
        } else {
          e.x--;
          e.mx++;
        }
      } else {
        doneX = true;
      }

      let doneY = false;
      if (e.my >= 1) {
        // can we move 1 pixel down?
        if (isSolidDown(e.x, e.width, e.y + e.height - 1)) {
          // hit ground
          const ody = e.dy;
          e.my = 0;
          e.dy = 0;
          e.air = 0;
          doneY = true;
          e.fire('bonk-down', ody);
        } else {
          e.air++;
          e.y++;
          e.my--;
        }
      } else if (e.my < 0) {
        // can we move 1 pixel up?
        if (isSolidUp(e.x, e.width, e.y, boss)) {
          // hit ceiling
          e.my = 0;
          e.dy = 0;
          doneY = true;
          e.fire('bonk-up', boss);
        } else {
          e.air++;
          e.y--;
          e.my++;
        }
      } else {
        doneY = true;
      }

      if (doneX && doneY) break;
    }
    if (e.dy >= 0 && isSolidDown(e.x, e.width, e.y + e.height - 1)) e.fire('bonk-down');
  }

  // camera
  if (targetEntity) {
    const cx = targetEntity.x + targetEntity.width * 0.5;
    const cy = targetEntity.y + targetEntity.height * 0.5;
    // figure out what vert we're in
    let vi = 1;
    while (vi < L.verts.length - 1 && L.verts[vi] < Math.floor(cx / tileSize)) vi++;
    const left = (L.verts[vi - 1] + 1) * tileSize;
    const right = L.verts[vi] * tileSize;
    cameraX = Math.max(left, Math.min(right - 160, cx - 80));
    cameraY = Math.max(0, Math.min(L.height * tileSize - 144, cy - 72));
    if (vclampCamera) {
      cameraY = Math.max(396, Math.min(417, cameraY));
    }
  }
}

function redraw() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillStyle = ic.clearColor;
  ctx.fillRect(0, 0, 160, 144);

  if (gameMode === 'title') {
    ctx.drawImage(ic.title, 0, 0);
    return;
  } else if (gameMode === 'choose') {
    playerEntity.draw();
    return;
  }
  // otherwise, game

  ctx.drawImage(ic.bg, Math.floor(-cameraX / 2), Math.floor(-cameraY));

  // draw boss underneath
  for (const e of entities) {
    if (!e.alive) continue;
    if (e instanceof BossMonsterEntity) {
      e.draw(Math.floor(-cameraX), Math.floor(-cameraY));
    }
  }

  if (playerEntity.drawBehind) {
    playerEntity.draw(Math.floor(-cameraX), Math.floor(-cameraY));
  }

  const xi = Math.floor(-cameraX / tileSize);
  const xf = Math.floor(-cameraX) - xi * tileSize;
  const yi = Math.floor(-cameraY / tileSize);
  const yf = Math.floor(-cameraY) - yi * tileSize;
  const xMax = Math.ceil(160 / tileSize);
  const yMax = Math.ceil(144 / tileSize);
  for (let y = -1; y < yMax; y++) {
    const wy = y - yi;
    for (let x = -1; x < xMax; x++) {
      const wx = x - xi;
      const k = (
        wx < 0 || wx >= L.width ||
        wy < 0 || wy >= L.height
      ) ? 0 : (debug ? L.solid : L.world)[wx + wy * L.width];
      const k1 = k & 0x77ff;
      if (k1 > 1)
        drawTile(k1, x * tileSize + xf, y * tileSize + yf);
    }
  }

  for (const e of entities) {
    if (!e.alive) continue;
    if (
      !(e instanceof BossMonsterEntity) &&
      e !== playerEntity
    ) {
      e.draw(Math.floor(-cameraX), Math.floor(-cameraY));
    }
  }

  if (!playerEntity.drawBehind) {
    playerEntity.draw(Math.floor(-cameraX), Math.floor(-cameraY));
  }

  for (let y = -1; y < yMax; y++) {
    const wy = y - yi;
    for (let x = -1; x < xMax; x++) {
      const wx = x - xi;
      const k = (
        wx < 0 || wx >= L.width ||
        wy < 0 || wy >= L.height
      ) ? 0 : L.front[wx + wy * L.width];
      const k1 = k & 0x77ff;
      if (k1 > 0)
        drawTile(k1, x * tileSize + xf, y * tileSize + yf);
    }
  }

  // draw hearts
  for (let i = 0; i < maxHearts; i++) {
    drawImage(ic.sprites, playerEntity.hearts > i ? 32 : 48, 240, 16, 16, i * 8, 0, 0);
  }
  // draw keys
  for (let i = 0; i < 3; i++) {
    if (playerEntity.keys <= i) break;
    drawImage(ic.sprites, 74, 232, 16, 16, 145 - i * 10, 1, 0);
  }
  // draw score
  const sctxt = `000000${Math.min(999999, playerEntity.score)}`.substr(-6);
  for (let i = 0; i < sctxt.length; i++) {
    const dig = sctxt.charCodeAt(i) - '0'.charCodeAt(0);
    drawImage(ic.sprites, 128 + 8 * dig, 224, 8, 8, 62 + 6 * i, 3, 0);
  }
  if (theEnd) {
    drawImage(ic.sprites, 16, 272, 96, 32, 32, 16, 0);
  }
}

function loadLevel(li) {
  currentLevel = li;
  vclampCamera = false;
  invincible = false;
  ignoreSpawnerIds = [];
  L = loadLevelLayer(levels[li][0]);
  LO = loadLevelLayer(levels[li][1]);
  playerEntity.setSpawn(L.startX, L.startY);
  playerEntity.respawn();
  spawnEntities();
}

function spawnEntities() {
  entities = [playerEntity];
  for (const s of L.spawners) {
    if (ignoreSpawnerIds.indexOf(s.id) < 0) {
      entities.push(s.f());
    }
  }
}

let nextItemId = 0;
function loadLevelLayer(level) {
  const width = level.width;
  const height = level.height;
  const world = [];
  const solid = [];
  const front = [];
  const doors = [];
  const spawners = [];
  let startX = 0;
  let startY = 0;
  const base = level.layers.find(l => l.name === 'base');
  const sold = level.layers.find(l => l.name === 'solid');
  const frnt = level.layers.find(l => l.name === 'front');
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      {
        let d = base.data[x + y * width] - 1;
        const flipH = (d & 0x80000000) !== 0;
        const flipV = (d & 0x40000000) !== 0;
        const flipR = (d & 0x20000000) !== 0;
        d = d < 0 ? d : d & 0x7ff;
        d = d |
          (flipH ? 0x4000 : 0) |
          (flipV ? 0x2000 : 0) |
          (flipR ? 0x1000 : 0);
        world.push(d);
      }

      {
        let d = (sold.data[x + y * width] - 1) & 0x7ff;
        if (d === 19) {
          startX = x * tileSize;
          startY = y * tileSize;
          d = 1;
        }
        if (d >= 20 && d < 32) {
          doors.push({ x: x, y: y, door: Math.floor((d - 20) / 2) });
        }
        if (d === 13 || d === 14 || d === 18 || (d >= 45 && d < 64)) {
          let mx = x * tileSize;
          let my = y * tileSize;
          let f = false;
          let id = nextItemId++;
          const dd = d;
          switch (d) {
            case 13:
            case 14:
            case 18:
              f = () => new ItemEntity(mx, my,
                dd === 13 ? 'heart' : dd === 14 ? 'coin' : 'key',
                id
              );
              break;
            case 45: // S1 SwampMonster
              f = () => new SwampMonsterEntity(mx, my, 5, -6.5);
              break;
            case 46: // S2
              f = () => new SwampMonsterEntity(mx, my, 3, -5);
              break;
            case 47: // L1 WalkMonster
              f = () => new WalkMonsterEntity(mx, my);
              break;
            case 48: // L2
              break;
            case 49: // B1 BatMonster
              f = () => new BatMonsterEntity(mx, my);
              break;
            case 50: // B2
              break;
            case 51: // D1 DripMonster
              f = () => new DripMonsterEntity(mx, my);
              break;
            case 52: // D2
              break;
            case 53: // Z1 ZombieMonster
              f = () => new ZombieMonsterEntity(mx, my - 11);
              break;
            case 54: // Z2
              break;
            case 55: // G1 GhostMonster
              f = () => new GhostMonsterEntity(mx, my, 21, 21, 5, 2, 0.02);
              break;
            case 56: // G2
              f = () => new GhostMonsterEntity(mx, my + 3, 13, 13, 3, 0.5, 0.04);
              break;
            case 57: // G3
              break;
            case 58: // C1
              f = () => new ThrowMonsterEntity(mx, my);
              break;
            case 59: // C2
              f = () => new HiddenMonsterEntity(mx, my);
              break;
            case 60: // C3
              f = () => new BossMonsterEntity(mx, my);
              break;
            case 61: // ??
            case 62: // ??
            case 63: // ??
              break;
          }
          if (!f) {
            console.warn('Missing spawner logic for', d);
          } else {
            spawners.push({ id, f });
          }
          d = 1;
        }
        solid.push(d);
      }

      {
        let d = frnt.data[x + y * width] - 1;
        const flipH = (d & 0x80000000) !== 0;
        const flipV = (d & 0x40000000) !== 0;
        const flipR = (d & 0x20000000) !== 0;
        d = d < 0 ? d : d & 0x7ff;
        d = d |
          (flipH ? 0x4000 : 0) |
          (flipV ? 0x2000 : 0) |
          (flipR ? 0x1000 : 0);
        front.push(d);
      }
    }
  }

  const verts = [-1];
  for (let x = 0; x < width; x++) {
    let vert = true;
    for (let y = 0; y < height && vert; y++) {
      vert = solid[x + y * width] === 6;
    }
    if (vert) {
      verts.push(x);
    }
  }
  verts.push(width);

  return { width, height, world, solid, front, doors, startX, startY, verts, spawners };
}

function start() {
  ic.setPalette(0x000000, 0x3a3a3a, 0x7a7a7a, 0xc0c0c0);
  loadLevel(0);
  let frameCount = 0;
  let nextFPS = Date.now() + 1000;
  let nextFrame = Date.now();
  function run() {
    const now = Date.now();
    let i = 0;
    while (nextFrame < now) {
      tickStart();
      tick();
      tickEnd();
      frameCount++;
      if (now >= nextFPS) {
        if (beatGame) {
          fps.innerText =
            (totalTime.endNow - totalTime.startNow) + ' ms // ' +
            (totalTime.endFrames - totalTime.startFrames) + ' frames';
          nextFPS = now + 1000000;
        } else {
          fps.innerText = 'FPS: ' + frameCount;
          frameCount = 0;
          nextFPS = now + 1000;
        }
      }
      nextFrame += 1000 / targetFPS;
      i++;
      if (i >= 4) {
        // too slow :-(
        nextFrame = Date.now();
      }
    }
    setTimeout(run, 0);
  }
  run();
}

function onKey(key, down){
  switch (key) {
    case 'ArrowUp':
      if (down && !keyboard.up)
        keyboard.hitUp = true;
      keyboard.up = down;
      return true;
    case 'ArrowDown':
      if (down && !keyboard.down)
        keyboard.hitDown = true;
      keyboard.down = down;
      return true;
    case 'ArrowLeft':
      if (down && !keyboard.left)
        keyboard.hitLeft = true;
      keyboard.left = down;
      return true;
    case 'ArrowRight':
      if (down && !keyboard.right)
        keyboard.hitRight = true;
      keyboard.right = down;
      return true;
    case 'Enter':
      if (down && !keyboard.start)
        keyboard.hitStart = true;
      keyboard.start = down;
      return true;
    case 'x':
    case ' ':
      if (down && !keyboard.jump)
        keyboard.hitJump = true;
      keyboard.jump = down;
      return true;
    case 'z':
      if (down && !keyboard.second)
        keyboard.hitSecond = true;
      keyboard.second = down;
      return true;
  }
  return false;
}

function onKeyDown(e){
  if (onKey(e.key, true)) {
    e.preventDefault();
    e.stopPropagation();
    return false;
  }
}

function onKeyUp(e){
  if (onKey(e.key, false)) {
    e.preventDefault();
    e.stopPropagation();
    return false;
  }
}

function onBlur(){
  keyboard.up = false;
  keyboard.hitUp = false;
  keyboard.down = false;
  keyboard.hitDown = false;
  keyboard.left = false;
  keyboard.hitLeft = false;
  keyboard.right = false;
  keyboard.hitRight = false;
  keyboard.jump = false;
  keyboard.hitJump = false;
  keyboard.second = false;
  keyboard.hitSecond = false;
}

window.addEventListener('keydown', onKeyDown);
window.addEventListener('keyup', onKeyUp);
window.addEventListener('blur', onBlur);

const fetchLevel = (name, i) => {
  levelNames[i] = name;
  return Promise.all([
    fetch('./level' + name + 'a.json').then(r => r.json()),
    fetch('./level' + name + 'b.json').then(r => r.json())
  ]).then(r => { levels[i] = r; });
};

// load everything
Promise.all([
  ic.load('tiles', './tiles.png'),
  ic.load('sprites', './sprites.png'),
  ic.load('boss', './boss.png'),
  ic.load('title', './title.png'),
  ic.load('bg', './bg.png'),
  fetchLevel('1-1', 0),
  fetchLevel('2-1', 1),
  fetchLevel('3-1', 2),
  fetchLevel('4-1', 3),
]).then(start);

  </script>
</body>
</html>
